List
-요소를 계속 넣을 수 있다.
-index가 존재한다.
-중복된 데이터 허용

add(E e) 			맨뒤에 추가
add(int index, E e) 		원하는 위치에 추가
set(int index, E e)		원하는 위치 수정
E remove(int idex)		
remove(Object obj)
removeAll(Collection c) 	삭제하고 true,false
clear() 			삭제하고 끝

LinkedList
node객체

ArrayList vs LinkedList
ArrayList -> 조회가 많은 곳
LinkedList -> 추가,삭제가 빈번하게 일어나는 곳

제네릭
-타입을 미리 지정하는 것이 아닌 객체가 만들어 질때 타입설정을 하는 것

public class 클래스명 <T> {

}

public interface 인터페이스명 <T>{

}

HashSet
-중복허용 X
-순서대로 저장된다는 보장이 없음

add()
remove()

컬렉션의 요소의 개수를 알고 싶을 때
size()

특정개체가 컬렉션에 들어있냐
contains(Object obj)

Iterator
반복자
컬렉션 요소를 순회하여 하나씩 추출하는 방식
생성한 List,Set 객체를 생성한다.

Iterator<Integer> iter = list.iterator();



TreeSet 
-이진탐색트리 중에서도 성능을 향상시킨 레드블랙트리로 구현되어있다.
-레드블랙트리는 부모노드보다 작은 값을 가지는 노드는 왼쪽
큰 값을 가지는 노드는 오른쪽으로 배치한다.
-데이터의 추가나 삭제시 트리가 한쪽으로 치우쳐져지지 않도록 균형을 맞춰준다. 


Map
-List,Set과 달리 Map인터페이스가 별도로 존재하며, 데이터를 List계열 컬렉션과
다르게 처리한다.
-데이터를 Key와 Value로 구분하여 저장하는 key-value방식을 사용한다.
-index는 없지만 key를 통해서 값을 검색하기 때문에 많은 양의 데이터를 
조회하는 데 있어 매우 뛰어난 성능을 발휘

HashMap
-map을 구현하고 있는 자식 클래스에서 가장 많이 사용하는 구현체이다.

------------------------------------------------------------------------------

제네릭 사용시 주의사항
1.제네릭 타입의 객체는 생성할 수 없다.
-제네릭 타입 자체로 객체를 생성하는 것은 불가능
T t = new T(); -> X

2.static멤버에 제네릭 타입이 올 수 없음
-static멤버는 클래스가 동일하게 공유하는 변수로서 제네릭 객체가
생성되기 전에 이미 자료 타입이 정해져 있어야 하기 때문이다.

2-1 static메서드의 반환타입으로 사용이 불가능
public static T getAge(int n){
			 -> X
}

2-2 static메서드의 매개변수 타입으로 사용이 불가능하다.
public static void setAge(T age){
			      -> X
}

3. 제네릭으로 배열 선언시 주의할 점
- 기본적으로 제네릭 클래스 자체를 배열로 만들 수는 없다.

Student<Integer>[]  arr1 = new Student<>[10]; -> X

제네릭 타입에 클래스가 들어온다는 것은, 클래스끼리 상속을 통해 관계를
맺는 다형성이 그대로 적용되지 않을까?


중첩타입 파라미터
-제네릭 객체를 제네릭 타입 파라미터로 받는 형식으로 표현할 수 있다.
-ArrayList자체로도 하나의 타입으로서 제네릭 타입 파라미터가 될 수 있기 때문에
중첩 형식으로 사용할 수 있다.


제네릭 인터페이스
-인터페이스를 구현(implements)한 클래스에서도 오버라이딩한 메서드를
제네릭 타입에 맞춰서 똑같이 구현해야 한다.


제네릭메서드
메서드에만 적용되는 제네릭타입

제네릭타입 범위 한정하기
-제네릭에 타입을 지정해줌으로서 클래스의 타입을 컴파일시에 정하여 타입예외에 대한 
안정성을 확보하는 것은 좋지만 문제는 너무 자유롭다는 점이다.

타입 한정 키워드 extends

<T extends 제한타입>

extends 키워드 뒤에 올 타입은 일반클래스, 추상클래스, 인터페이스 모두 가능하다.

다중타입한정
-만일 2개 이상의 타입을 동시에 구현한 경우 타입 제한을 하고 싶다면 &연산자를 사용한다.
-해당 인터페이스들을 동시에 구현한 클래스가 제네릭 타입에 대상이 되게 한다.
-단, 자바에서는 다중 상속을 지원하지 않기 때문에 클래스로는 다중extends는 불가능하고
오로지 인터페이스로만이 가능하다.


제네릭의 형변환
-제네릭 형변환
배열과 같은 일반적인 변수 타입과 달리 제네릭 서브 타입간에는 형변환이 불가능하다.
자연스럽게 다형성이 적용될 것이라고 생각할 수 있지만, 실상 제네릭은 전달 받은 타입으로만
캐스팅이 가능하다.

제네릭 타입은 상하관계가 없다.
제네릭 타입변수끼리는 아무리 상속관계에 놓인다 한들 형변환이 불가능하다.

제네릭 와일드카드
제네릭 간의 형변환을 성립되게 하기 위해서는 제네릭에서 제공하는 와일드카드
문법을 이용해야 한다.

<?>: Unbounded WildCards(제한없음)
-타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다.

<? extends 상위타입> : Upper Bounded WildCards(상위 클래스 제한)
-타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나, 상위타입의 하위 타입만 올 수 있다.

<? super 하위타입> : Lower Bounded WildCards(하위 클래스 제한)
-타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 하위타입의 상위 타입만 올 수 있다.

-------------------------------------------------------------------------------------------------------

람다식
-JDK1.8부터 함수형 프로그램밍 '람다식(lamda expression)'을 지원한다.
-람다식은 이름이 없는 익명함수를 만들기 위한 표현식을 말한다.
-자바는 객체를 기반으로 프로그램을 구현하는 객체지향프로그램이다.
-클래스를 먼저 생성하고, 클래스 안에 메서드와 객체를 선언해 사용해야 한다.
-하지만 함수형 프로그래밍은 객체 지향 프로그램과 달리 함수만을 
구현하고 실행할 수 있는 개발방식이다.

람다식이 도입된 이유
-함수형 프로그래밍 방식
-자바에서는 함수형 프로그래밍 방식이 적용되지 않았다.
-자바는 클래스에 함수를 정의하고 객체를 통해 호출하는 방식을 사용하고 있다.

람다식 문법
-기존의 자바문법과는 달라서 객체지향 프로그래밍에 익숙한 개발자들은 다소
생소할 수 있다.
-하지만 문법이 간결해지고, 원하는 결과를 쉽게 집계할 수 있어 익숙해지면
큰 장점이 있다.

int add(int x, int y){
	return x+y;
}

위 함수를 람다식으로 표현하기

(int x, int y) -> {return x+y;}

-메서드의 이름과 반환형을 제거하고 화살표를 이용해 구현한다.

소괄호 생략하기
-람다식 문법에서는 파라미터의 자료형을 생략할 수 있다.
(x, y) -> {return x+y;}
-파라미터가 한 개인 경우 소괄호도 생략할 수 있다.
(String str) -> {System.out.println(str);}

str -> {System.out.println(str);}

중괄호 생략하기
-함수의 반환형이 void라면 중괄호도 생략할 수 있다.
str -> System.out.println(str);

-반환형이 있을 때 return키워드와 중괄호를 같이 생략할 수 있다.
(x, y) -> x+y;

함수형 인터페이스
-객체지향 프로그램에서 인터페이스를 이용하기 위해서는 구현체를 만든 뒤 사용해야 한다.
-람다식은 위와 같은 과정을 생략할 수 있다.
-단, 람다식을 이용해 인터페이스를 사용할 경우, 인터페이스 안에는 하나의 추상메서드만 
작성할 수 있다.
-람다식을 구현하기 위해서는 먼저 인터페이스를 만들고, 인터페이스에 람다식으로 구현할
메서드를 선언해야 한다.
-오직 하나의 추상 메서드가 선언된 인터페이스만이 람다식의 타겟이 되는데 
-이를 함수형 인터페이스 라고 한다.



