추상화
-공통성과 본질을 모아 추출하는 것
-기존 클래스들의 공통적인 요소들을 모아 클래스를 만들어 내는 기술

장점
반복되는 코드를 줄일 수 있다.
효과적으로 클래스간의 관꼐를 설정하여 유지보수가 용이해 진다.


추상클래스를 직접 객체화 할 수 없다.

만약 추상메서드를 하나라도 가지고 있다면 추상클래스로 정의해야 한다.

추상메서드
선언부만 작성하고 body는 없는 메서드

public abstract 반환형 메서드명(매개변수);
abstract public 반환형 메서드명(매개변수);

추상클래스를 상속받는 클래스들이 추상메서드를 상속받아 '무조건'
오버라이드(재정의)해야한다.

인터페이스
상수 -> 값을 초기화 하면, 다시 대입이 불가능
상수의 이름은 대문자로 작성한다.
추상메서드 ->abstract 생략해도 된다.
인터페이스도 객체 생성이 안된다.

다중 인터페이스의 구현 
- 하나의 클래스로 여러개의 인터페이스를 구형할 수 있다.
- 선언한 모든 인터페이스에 대한 추상메서드를 모두 구현해야 한다.

class 클래스명 implements 인터페이스명1, 인터페이스명2{
	필드,메서드,생성자,추상메서드의 구현체
}



인터페이스 상속
인터페이스끼리 상속관계를 만들 수 있다.
클래스에서의 상속과 마찬가지로 extends 키워드를 사용하며, 다중 상속이 가능하기 때문에
콤마를 이용해서 여러개를 상속하는 것이 가능

interface 인터페이스명 extends 인터페이스1, 인터페이스2, .... {

}

인터페이스 상속을 선언하면, 자식(하위) 인터페이스는 부모(상위)인터페이스의 모든 
멤버를 상속받게 된다.

자식(하위)인터페이스를 구형하는 클래스가 있다면, 해당 클래스는 자식(하위) 인터페이스의 
추상 메서드를 포함하여 부모(상위) 인터페이스들의 추상메서드까지 구현해야 한다. 


내부 클래스
-클래스 안에 만들어진 또 다른 클래스로 중첩클래스라고도 부른다.
-클래스 안에 다른 클래스를 선언하는 이유는 두 개의 클래스가 서로 
긴밀한 관계를 맺고 있기 때문이다.

내부 클래스의 장점
-두 클래스 멤버들 간에 손쉽게 접근할 수 있다.
-불필요한 클래스를 감춰  코드의 복잡성을 줄일 수 있다. 

public class OuterClass{
	clss InnerClass{
	
	}
}

내부클래스의 종류

인스턴스 클래스
외부클래스의 필드와 같은 위치에 선언
주로 외부클래스의 클래스 멤버젼수와 관련된 작업에 사용될 목적으로 선언

정적클래스
클래스의 클래스변수처럼(정적변수) 내부클래스에 static을 붙힌 클래스

지역클래스
외부 클래스의 메서드 내부에서 선언하여 사용
메서드 영역에서 선언되기 때문에 메서드 내부에서만 사용이 가능

인스턴스클래스
외부클래스 내부에서 생성하고, 선언되어 사용하는 클래스 
외부클래스의 필드와 같은 위치에 선언하며, 외부 클래스의 필드처럼 다뤄진다.
주로 외부클래스의 필드들과 관련된 작업에 사용될 목적으로 선언된다.


public class Outer{

    private String name; // 필드
    
    //인스턴스클래스가 들어갈 수 있다.
    public class Inner{
         private int age;
    }
}

내부 클래스도 외부 클래스 안에 생성되는 것 외에는 별도의 클래스이기때문에,
파일이 커파일 되면 별도로 생성된다.

인스턴스 클래스의 객체화
-인스턴스 클래스는 기본적인 내부클래스이다.
-외부 클래스 안에 생성되기 때문에, 클래스를 사용하려면 외부클래스의 객체가
생성된 상태에서 객체를 생성할 수 있다.

Outer outer = new Outer(); //외부클래스의 객체 생성
           └-----------↓
Outer.Inner inner = outer.new Inner();


정적 내부 클래스(static class)
- 클래스 안에 정적변수를 선언할 수 있는 것 처럼
클래스도 정적 내부 클래스를 만들 수 있다.
- 필드와 마찬가지로 static키워드를 사용해 클래스를 선언한 후
정적 내부 클래스를 생성한다.
- 주로 외부 클래스의 static메서드에서 사용될 목적으로 만든다.


public class Outer{
    private String name;
    public static class Inner{
	private String name;
    }
}


-외부 클래스의 필드 또는 메서드를 정적 내부 클래스 안에서는 사용할 수 없다.

public class Outer{
   private int val1;

   public static class Inner{
          public void add(){
         	    int result = val1 +10; -> 에러
          }   

    }
}

정적 내부 클래스는 정적 변수 또는 정적메서드를 호출하는 것은 가능하다.

public class Outer{
   private int val1;  일반적인 필드
   private static int cnt =1;  정적변수

   public static class Inner{
          public void displayOuterInfo(){
         	   System.out.println(val) -> 에러
	   System.out.println(cnt) -> 정상실행 
          }   

    }
}

정적 내부 클래스의 객체 생성
Outer.Inner in = new Outer.Inner();

지역클래스(local class)
-외부클래스의 메서드 안에서 선언하여 사용하는 클래스
-메서드 내에서 선언되기 때문에 해당 클래스는 메서드 내에서만 사용할 수 있다.
-메서드의 실행이 끝나면 해당 클래스도 사용이 종료된다.


public class LocalClass{
	public void print(){
		///////////////////////////
		class A{
		
		}

		A a = new A(); 
		///////////////////////////
	}

}

내부 클래스의 접근 제한 
-내부 클래스도 클래스이기 때문에 접근제한자를 붙여 사용할 수 있다.



지역클래스의 접근 제한
-지역클래스는 메서드 내에서 선언되어 사용한다.
-보통 메서드가 종료되면 클래스도 함께 종료되지만 메서드와 실행되는 위치가
 다르기 때문에 종료되지 않고 남아있을수도 있다.
-그래서 지역클래스에서 메서드 내의 변수를 사용할 때는 변수를 복사해 사용한다.
-이러한 이유로 지역 클래스에서 메서드의 변수를 사용할 때 변수가 변경되면
오류가 발생한다.

익명클래스(anonymous class)
-이름이 없는 클래스
-익명클래스는 클래스의 선언과 객체의 생성을 동시에 하므로 한번만 사용할 수 있다.
-오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다
-따라서 생성자를 선언할 수도 없으며, 둘 이상의 인터페이스를 구현할 수도 없다.


-----------------------------------------------------------------------------------------
예외처리
에러(error)와 예외(exception)
프로그램을 실행하다보면 갑자기 프로그램이 종료되거나, 어떤 원인에 의해 잘못
동작하여 오류 메세지가 나타나는 등 예기치 못한 오류가 발생한다.
전자는 우리가 해결할 수 없는 시스템 에러가 발생해 프로그램이 종료된 경우
후자는 프로그램 사용 중 발생한 오류를 개발자가 처리해 메세지가 출력된 경우

에러(error)
-시스템에 비정상적인 상황이 생겼을 때 발생한다.
-외부요인일수도 있고, 프로그램 구동 중에 발생하는 치명적인 오류일 수도 있다.
이러한 에러들은 개발자가 예측하거나 처리할 수 없는 영역이다.

OutOfMemoryError : 프로그램 실행중 메모리 부족
IOError : 입출력에러
StackOverFlowError: 가용 메모리 부족 현상, 재귀 호출 문제시 발생

예외(exception)
-대체로 프로그램 구동 중 나타난는 오류들
-문법적으로는 문제가 없어보이지만 실제 운영 중에 생기는 문제들
-체크예외 비체크예외 두가지가 있다.

체크예외
자바 소스를 컴파일 하는 과정에서 검사한다.
보통 문법적으로 강제하여 예외처리를 해야 하는 경우

비체크예외
-컴파일 과정에서 검사하지 않으므로 사용자의 경험이나 테스트로 찾아야 하는 경우

예외클래스
자바는 객체지향 언어이고 따라서 프로그램에서 발생하는 예외들은 클래스 형태로 제공된다.

NullPointException
객체가 제대로 생성되지 않은 상태에서 사용할 경우 발생한다.
객체를 선언하면,주소를 갖게 되고, 그것을 통해 객체에 접근해 값을 가져온다.
객체변수는 정의되었는데 메모리에 올리지 않았을 때 예외가 발생한다.

예외처리문법
-예외가 발생했을 때, 어떻게 예외를 처리하는지 방법을 보자

예외 처리 과정
1.코드 진행 중 예외가 발생하면 JVM에게 알린다.
2.JVM은 발생한 예외를 분석하여 알맞은 예외 클래스를 생성한다.
3.생성된 예외 객체를 발생한 지점으로 보낸다.
4.예외가 발생한 지점에서 처리하지 않으면 프로그램은 비정상 종료된다.

try-catch 구문
예외를 처리하는 가장 기본 문법은 try-catch문이다.
예외가 발생할 가능성이 있는 코드는 try{}영역 안에 자성하고
catch메서드는 시스템으로부터 넘어오는 예외 클래스를 받아서 처리한다.

try{
    예외가 발생할 가능성이 있는 코드
}catch(예외 클래스명 e){
    예외처리 코드
}


예외 던지기

메서드 내부에서 예외를  처리하지 않고 미룬 후, 해당 메서드를 
호출한 쪽에서 예외를 처리하는 방법

throws
메서드 뒤에 throws키워드를 사용하여 던지기 할 예외 객체를 붙여주면 된다.
예외 객체는 여러개를 던질 수 있으며, 여러개를 던질 시 콤마로 구분하여 나열해 준다.   